<!DOCTYPE html>
<html lang="ko" class="">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>파티 플래너</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#2c3e50',
                        'primary-hover': '#34495e',
                        'dark-bg': '#18181b',
                        'dark-surface': '#27272a',
                        'dark-border': '#3f3f46',
                        'dark-text': '#e4e4e7',
                        'dark-text-muted': '#a1a1aa',
                    }
                }
            }
        }
    </script>
    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
        }
        .card {
            border-radius: 12px;
        }
        /* 성능 최적화: transition 최소화 및 구체적 속성 지정 */
        .char-card {
            transition: border-color 0.1s, background-color 0.1s;
            cursor: pointer;
        }
        /* 호버 시 나타나는 버튼 그룹 트랜지션 */
        .char-card .hover-actions {
            transition: opacity 0.1s ease-in-out;
        }

        .char-card.cleared {
            background-color: #ecfdf5;
            border-color: #a7f3d0;
            color: #065f46;
        }
        .dark .char-card.cleared {
             background-color: rgba(6, 95, 70, 0.2);
             border-color: #065f46;
             color: #d1fae5;
        }

        .set-card {
            border-radius: 10px;
            /* 성능 최적화: transition 최소화 */
            transition: border-color 0.1s;
        }
        .set-card.cleared {
            background-color: #ecfdf5;
            border-color: #a7f3d0;
			box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }
        .dark .set-card.cleared {
            background-color: rgba(6, 95, 70, 0.2);
            border-color: #065f46;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .status-bar-bg {
            height: 10px;
            background: #e4e4e7;
            border-radius: 5px;
        }
        .dark .status-bar-bg { background: #3f3f46; }

        .status-bar-fill {
            height: 100%;
            background: #34d399;
            border-radius: 5px;
            transition: width 0.3s ease; /* 속도 약간 빠르게 */
        }
        
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #94a3b8; border-radius: 10px; }
        .dark ::-webkit-scrollbar-thumb { background: #4b5563; }
        
        .modal {
            background: rgba(0,0,0,0.6);
            display: none;
            position: fixed;
            inset: 0;
            z-index: 100;
            align-items: center;
            justify-content: center;
            /* backdrop-filter: blur(4px); 성능을 위해 블러 제거 고려 */
        }
        .modal.active { display: flex; }

        .editing-char-box {
            background: #fdf2f2;
            border: 2px solid #ef4444 !important;
        }
        .dark .editing-char-box {
             background: rgba(127, 29, 29, 0.2);
             border-color: #991b1b !important;
        }

        .tab-btn {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .move-btn {
            padding: 4px;
            border-radius: 6px;
            transition: background-color 0.1s;
            display: none;
        }
        .tab-active .move-btn {
            display: flex;
        }
        .move-btn:hover {
            background: rgba(255,255,255,0.2);
        }
        .tab-inactive .move-btn {
            display: none;
        }
        
        .toggle-checkbox:checked {
            right: 0;
            border-color: #34d399;
        }
        .toggle-checkbox:checked + .toggle-label {
            background-color: #34d399;
        }
        #toggle-switch-dot {
             transition: transform 0.2s ease-in-out; /* 속도 빠르게 */
        }
        .dark #toggle-switch-dot {
            transform: translateX(100%);
        }

        /* 메모장 관련 스타일 */
        #notepad-modal {
            /* 기본 위치 중앙 배치를 위한 스타일, JS로 덮어씌워짐 */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1);
        }
        
        /* 이미지 스타일 수정: max-width 제거하여 고정 크기 유지 */
        #notepad-content img {
            max-width: none !important; 
            height: auto;
            cursor: pointer;
            display: inline-block;
        }

        /* 이미지 선택 시 래퍼 스타일 */
        .image-resizer-wrapper {
            display: inline-block;
            position: relative;
            outline: 2px solid #3b82f6; /* 파란색 테두리 */
            margin: 4px; /* 약간의 여백 */
        }

        /* 이미지 리사이즈 핸들 (우측 하단) */
        .image-resizer-handle {
            position: absolute;
            bottom: -6px;
            right: -6px;
            width: 12px;
            height: 12px;
            background-color: #3b82f6;
            border: 1px solid white;
            cursor: se-resize;
            z-index: 10;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }

        /* 메모장 자체 리사이즈 핸들 */
        .resizer {
            position: absolute;
            width: 15px;
            height: 15px;
            background: transparent;
            z-index: 2;
        }
        /* 우측 하단 메모장 리사이즈 핸들 스타일 (빗금 표시) */
        .resizer.se {
            bottom: 0;
            right: 0;
            cursor: se-resize;
            /* 빗금 무늬 그라데이션 */
            background-image: linear-gradient(135deg, transparent 45%, #a1a1aa 45%, #a1a1aa 50%, transparent 50%, transparent 70%, #a1a1aa 70%, #a1a1aa 75%, transparent 75%);
            background-size: 10px 10px;
            opacity: 0.5;
        }
        .dark .resizer.se {
            background-image: linear-gradient(135deg, transparent 45%, #71717a 45%, #71717a 50%, transparent 50%, transparent 70%, #71717a 70%, #71717a 75%, transparent 75%);
        }
    </style>
</head>
<body class="p-4 md:p-8 bg-[#f4f4f5] dark:bg-dark-bg text-primary dark:text-dark-text transition-colors duration-100 relative"> <!-- body 트랜지션 속도 빠르게 -->

    <div id="app" class="max-w-[1800px] mx-auto">
<!-- 상단 바 -->
<div class="mb-4">
    <a href="index.html" class="inline-flex items-center text-sm font-bold text-zinc-500 dark:text-zinc-400 hover:text-primary dark:hover:text-dark-text transition-colors group">
        <svg class="w-4 h-4 mr-1 group-hover:-translate-x-1 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path></svg>
        메인으로 이동
    </a>
</div>
<div class="flex flex-col md:flex-row justify-between items-start md:items-center mb-10 gap-6">
    <div>
        <h1 class="text-3xl font-bold tracking-tight text-primary dark:text-dark-text">파티 플래너</h1>
        <p class="text-base text-zinc-500 dark:text-dark-text-muted mt-1">컨텐츠별 캐릭터 배치 및 클리어 현황 관리</p>
    </div>
    <div class="flex items-center gap-3">
        <!-- 메모장 버튼 -->
        <button onclick="toggleNotepad()" class="flex items-center gap-1 px-3 py-2.5 text-sm font-semibold border border-zinc-200 dark:border-dark-border rounded-lg hover:bg-zinc-50 dark:hover:bg-zinc-700 transition-colors shadow-sm bg-white dark:bg-dark-surface text-primary dark:text-dark-text mr-2">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg>
            메모장
        </button>

        <button onclick="toggleDarkMode()" aria-label="다크 모드 토글" class="relative inline-flex h-8 w-14 items-center rounded-full bg-zinc-300 dark:bg-zinc-600 transition-colors focus:outline-none shadow-inner">
            <span id="toggle-switch-dot" class="inline-block h-6 w-6 transform rounded-full bg-white dark:bg-zinc-200 shadow transition-transform duration-300 ease-in-out translate-x-1 flex items-center justify-center">
                <svg class="w-4 h-4 text-amber-500 dark:hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path></svg>
                <svg class="w-4 h-4 text-indigo-400 hidden dark:block" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path></svg>
            </span>
        </button>

        <button onclick="downloadBackup()" class="px-4 py-2.5 text-sm font-semibold border border-zinc-200 dark:border-dark-border rounded-lg hover:bg-zinc-50 dark:hover:bg-zinc-700 transition-colors shadow-sm bg-white dark:bg-dark-surface text-primary dark:text-dark-text">데이터 백업</button>
        
        <button onclick="confirmLoadData()" class="px-4 py-2.5 text-sm font-semibold border border-zinc-200 dark:border-dark-border rounded-lg hover:bg-zinc-50 dark:hover:bg-zinc-700 transition-colors shadow-sm cursor-pointer bg-white dark:bg-dark-surface text-primary dark:text-dark-text">
            데이터 로드
        </button>
        <input type="file" id="load-file" class="hidden" accept=".json" onchange="handleFileLoad(event)">
    </div>
</div>

        <!-- 전체 대시보드 -->
        <section class="card p-6 mb-10 shadow-sm bg-white dark:bg-dark-surface border border-zinc-200 dark:border-dark-border">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-base font-bold uppercase tracking-widest text-zinc-400 dark:text-dark-text-muted">전체 컨텐츠 클리어 현황</h2>
                <button onclick="confirmResetAll()" class="text-sm font-bold text-red-500 hover:text-red-700 dark:hover:text-red-400 transition-colors">모든 클리어 초기화</button>
            </div>
            <div id="dashboard-grid" class="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-6"></div>
        </section>

        <div class="grid grid-cols-1 lg:grid-cols-12 gap-8">
            <!-- 사이드바: 캐릭터 관리 -->
            <aside class="lg:col-span-5 xl:col-span-4">
                <div class="card p-6 shadow-sm bg-white dark:bg-dark-surface border border-zinc-200 dark:border-dark-border">
                    <!-- 헤더 수정: 모험단 불러오기 버튼 추가 -->
                    <div class="flex justify-between items-center mb-4 border-b dark:border-dark-border pb-3">
                        <h3 class="font-bold text-lg text-primary dark:text-dark-text">캐릭터 관리</h3>
                        <button onclick="openDundamModal()" class="text-sm bg-zinc-100 dark:bg-zinc-700 hover:bg-zinc-200 dark:hover:bg-zinc-600 transition-colors px-3 py-1.5 rounded-lg text-primary dark:text-dark-text font-bold">
                            모험단 불러오기
                        </button>
                    </div>
                    
                    <!-- 캐릭터 등록 폼 -->
                    <div class="space-y-3 mb-8 bg-zinc-50 dark:bg-zinc-800/50 p-4 rounded-xl border border-zinc-100 dark:border-dark-border">
                        <div class="flex gap-2">
                            <input id="char-name" type="text" placeholder="닉네임" class="w-full border dark:border-dark-border rounded-lg px-4 py-3 text-base outline-none focus:ring-2 focus:ring-zinc-200 dark:focus:ring-zinc-600 text-primary dark:text-dark-text bg-white dark:bg-dark-surface">
                        </div>
                        <div class="flex gap-2">
                            <input id="char-stat" type="number" placeholder="수치" class="w-1/2 border dark:border-dark-border rounded-lg px-4 py-3 text-base outline-none focus:ring-2 focus:ring-zinc-200 dark:focus:ring-zinc-600 text-primary dark:text-dark-text bg-white dark:bg-dark-surface">
                            <input id="char-note" type="text" placeholder="메모" class="w-1/2 border dark:border-dark-border rounded-lg px-4 py-3 text-base outline-none focus:ring-2 focus:ring-zinc-200 dark:focus:ring-zinc-600 text-primary dark:text-dark-text bg-white dark:bg-dark-surface">
                        </div>
                        <div>
                            <select id="char-type" class="w-full border dark:border-dark-border rounded-lg px-3 py-3 text-base bg-white dark:bg-dark-surface outline-none text-primary dark:text-dark-text">
                                <option value="dealer">딜러</option>
                                <option value="buffer">버퍼</option>
                            </select>
                        </div>
                        <button onclick="addCharacter()" class="w-full bg-primary dark:bg-zinc-700 text-white py-3.5 rounded-lg text-base font-bold hover:bg-primary-hover dark:hover:bg-zinc-600 transition-colors">새 캐릭터 등록</button>
                    </div>

                    <!-- 정렬 및 소수점 컨트롤 추가 -->
                    <div class="flex justify-end items-center mb-4 gap-2">
                        <select id="decimal-select" onchange="changeDecimalPlaces(this.value)" class="border dark:border-dark-border rounded-lg px-3 py-2 text-sm bg-white dark:bg-dark-surface outline-none text-primary dark:text-dark-text cursor-pointer hover:bg-zinc-50 dark:hover:bg-zinc-700 transition-colors">
                            <option value="0">소수점 0자리</option>
                            <option value="1" selected>소수점 1자리</option>
                            <option value="2">소수점 2자리</option>
                            <option value="3">소수점 3자리</option>
                        </select>
                        <select id="sort-select" onchange="changeSortMethod(this.value)" class="border dark:border-dark-border rounded-lg px-3 py-2 text-sm bg-white dark:bg-dark-surface outline-none text-primary dark:text-dark-text cursor-pointer hover:bg-zinc-50 dark:hover:bg-zinc-700 transition-colors">
                            <option value="desc">수치 내림차순</option>
                            <option value="asc">수치 오름차순</option>
                            <option value="name">이름순</option>
                        </select>
                    </div>

                    <div class="grid grid-cols-2 gap-4">
                        <div class="flex flex-col">
                            <h4 class="text-xs font-black text-zinc-400 dark:text-dark-text-muted mb-3 uppercase tracking-widest flex items-center gap-2">
                                <span class="w-2 h-2 bg-primary dark:bg-zinc-400 rounded-full"></span> 딜러
                            </h4>
                            <div id="dealer-list" class="space-y-2 max-h-[500px] overflow-y-auto pr-1"></div>
                        </div>
                        <div class="flex flex-col">
                            <h4 class="text-xs font-black text-emerald-500 dark:text-emerald-400 mb-3 uppercase tracking-widest flex items-center gap-2">
                                <span class="w-2 h-2 bg-emerald-500 rounded-full"></span> 버퍼
                            </h4>
                            <div id="buffer-list" class="space-y-2 max-h-[500px] overflow-y-auto pr-1"></div>
                        </div>
                    </div>
                </div>
            </aside>

            <!-- 메인: 컨텐츠 영역 -->
            <main class="lg:col-span-7 xl:col-span-8">
                <div class="card p-8 shadow-sm h-full bg-white dark:bg-dark-surface border border-zinc-200 dark:border-dark-border">
                    <div class="flex flex-wrap items-center gap-3 mb-8 border-b dark:border-dark-border pb-6">
                        <!-- 컨텐츠 탭 컨테이너 -->
                        <div id="content-tabs" class="flex flex-wrap gap-2.5"></div>
                        
                        <div class="flex items-center gap-2 ml-auto">
                            <input id="new-content-name" type="text" placeholder="새 컨텐츠" class="border dark:border-dark-border rounded-lg px-4 py-2 text-sm focus:ring-2 focus:ring-zinc-100 dark:focus:ring-zinc-600 outline-none w-32 bg-white dark:bg-dark-surface dark:text-dark-text">
                            <button onclick="addContent()" class="bg-zinc-100 dark:bg-zinc-700 text-primary dark:text-dark-text px-4 py-2 rounded-lg text-sm font-bold hover:bg-zinc-200 dark:hover:bg-zinc-600 transition-colors">추가</button>
                        </div>
                    </div>

                    <div id="active-content-area">
                        <div class="flex justify-between items-start mb-8">
                            <div>
                                <h2 id="current-content-title" class="text-3xl font-bold text-primary dark:text-dark-text tracking-tight"></h2>
                                <div id="content-edit-tools" class="flex gap-4 mt-2 hidden">
                                    <button onclick="renameContent()" class="text-sm text-zinc-400 dark:text-dark-text-muted hover:text-primary dark:hover:text-dark-text transition-colors underline underline-offset-4">컨텐츠 이름 변경</button>
                                    <button onclick="deleteContent()" class="text-sm text-red-300 hover:text-red-500 dark:text-red-400 dark:hover:text-red-300 transition-colors underline underline-offset-4">컨텐츠 삭제</button>
                                </div>
                            </div>
                            <div id="party-controls" class="flex gap-3 hidden">
                                <button id="edit-mode-btn" onclick="toggleEditMode()" class="px-5 py-2 border dark:border-dark-border rounded-lg text-sm font-bold transition-colors shadow-sm bg-white dark:bg-dark-surface hover:bg-zinc-50 dark:hover:bg-zinc-700 text-primary dark:text-dark-text">수정 모드</button>
                                <button onclick="openSetModal()" class="px-5 py-2 border dark:border-dark-border rounded-lg text-sm font-bold transition-colors shadow-sm bg-zinc-100 dark:bg-zinc-700 hover:bg-zinc-200 dark:hover:bg-zinc-600 text-primary dark:text-dark-text">세트 추가</button>
                                <button onclick="openAddCharModal()" class="bg-primary dark:bg-zinc-600 text-white px-5 py-2 rounded-lg text-sm font-bold hover:bg-primary-hover dark:hover:bg-zinc-500 transition-colors shadow-sm">캐릭터 추가</button>
                            </div>
                        </div>

                        <!-- 세트 영역 -->
                        <div id="content-sets-container" class="mb-10 hidden">
                            <h3 class="text-xs font-bold text-zinc-400 dark:text-dark-text-muted mb-4 flex items-center gap-2 uppercase tracking-widest">
                                <span class="w-1.5 h-1.5 bg-blue-500 rounded-full"></span> 세트(파티) 구성
                            </h3>
                            <div id="sets-grid" class="grid grid-cols-1 md:grid-cols-2 gap-4"></div>
                        </div>

                        <!-- 캐릭터 영역 -->
                        <div id="content-grid-container" class="grid grid-cols-1 md:grid-cols-2 gap-8 hidden">
                            <div>
                                <h3 class="text-xs font-bold text-zinc-400 dark:text-dark-text-muted mb-4 flex items-center gap-2 uppercase tracking-widest">
                                    <span class="w-1.5 h-1.5 bg-primary dark:bg-zinc-400 rounded-full"></span> 딜러
                            </h3>
                                <div id="dealer-grid" class="flex flex-col gap-2"></div>
                            </div>
                            <div>
                                <h3 class="text-xs font-bold text-zinc-400 dark:text-dark-text-muted mb-4 flex items-center gap-2 uppercase tracking-widest">
                                    <span class="w-1.5 h-1.5 bg-emerald-500 rounded-full"></span> 버퍼
                            </h3>
                                <div id="buffer-grid" class="flex flex-col gap-2"></div>
                            </div>
                        </div>

                        <div id="empty-content-msg" class="py-24 text-center text-zinc-400 dark:text-dark-text-muted text-lg">
                            관리할 컨텐츠를 선택하거나 새로 생성하세요.
                        </div>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <!-- 메모장 모달 (독립적인 floating box) -->
    <div id="notepad-modal" class="fixed hidden z-[9999] w-[500px] h-[600px] min-w-[300px] min-h-[400px] flex flex-col">
        <div class="bg-white dark:bg-dark-surface rounded-xl border dark:border-dark-border flex flex-col h-full overflow-hidden shadow-2xl relative">
            <!-- Header (Draggable) -->
            <div id="notepad-header" class="flex items-center justify-between p-3 border-b dark:border-dark-border bg-zinc-100 dark:bg-zinc-800 cursor-move select-none shrink-0">
                <!-- Left controls -->
                <div class="flex items-center gap-3">
                    <span class="font-bold text-sm flex items-center gap-1 text-primary dark:text-dark-text">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg>
                        메모장
                    </span>
                </div>
                <!-- Right controls -->
                <div class="flex items-center gap-3">
                    <div class="flex items-center mr-2" title="글자 크기 조절">
                         <input id="notepad-fontsize" type="number" value="24" min="8" max="96" class="w-14 px-2 py-1 text-sm border rounded dark:bg-dark-surface dark:border-dark-border text-center outline-none focus:border-primary dark:focus:border-zinc-500 text-primary dark:text-dark-text">
                         <span class="text-sm text-zinc-500 dark:text-dark-text-muted ml-1">pt</span>
                    </div>
                    <button onclick="clearNotepad()" class="text-xs font-bold text-red-500 hover:text-red-700 dark:hover:text-red-400 px-2 py-1 rounded hover:bg-red-50 dark:hover:bg-red-900/20 transition-colors">비우기</button>
                    <button onclick="toggleNotepad()" class="text-zinc-400 hover:text-primary dark:hover:text-dark-text p-1 hover:bg-zinc-200 dark:hover:bg-zinc-700 rounded transition-colors">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>
            </div>
            <!-- Content (Editable) -->
            <div id="notepad-content-container" class="flex-1 overflow-hidden relative">
                <div id="notepad-content" contenteditable="true" class="w-full h-full p-6 overflow-y-auto outline-none text-primary dark:text-dark-text leading-normal" style="font-size: 24pt;"></div>
            </div>
            
            <!-- Resizer Handles -->
            <div class="resizer se" id="notepad-resizer"></div>
        </div>
    </div>


    <!-- 캐릭터 일괄 추가 모달 -->
    <div id="add-char-modal" class="modal">
        <div class="bg-white dark:bg-dark-surface p-8 rounded-2xl shadow-2xl max-w-4xl w-full mx-4 border dark:border-dark-border">
            <h4 class="font-bold text-2xl mb-6 text-primary dark:text-dark-text">컨텐츠 캐릭터 추가</h4>
            <div class="grid grid-cols-2 gap-6 mb-8">
                <div class="flex flex-col border-r dark:border-dark-border pr-6" id="modal-dealer-list-container">
                    <div class="flex justify-between items-center mb-4">
                        <h5 class="text-sm font-black text-zinc-400 dark:text-dark-text-muted uppercase tracking-widest">딜러 목록</h5>
                        <button onclick="toggleAllChars('dealer')" class="text-xs font-bold text-primary dark:text-dark-text hover:underline" id="toggle-all-dealer-btn">전체 선택</button>
                    </div>
                    <div id="modal-dealer-list" class="max-h-[400px] overflow-y-auto space-y-2 pr-2"></div>
                </div>
                <div class="flex flex-col" id="modal-buffer-list-container">
                    <div class="flex justify-between items-center mb-4">
                        <h5 class="text-sm font-black text-emerald-500 dark:text-emerald-400 uppercase tracking-widest">버퍼 목록</h5>
                        <button onclick="toggleAllChars('buffer')" class="text-xs font-bold text-primary dark:text-dark-text hover:underline" id="toggle-all-buffer-btn">전체 선택</button>
                    </div>
                    <div id="modal-buffer-list" class="max-h-[400px] overflow-y-auto space-y-2 pr-2"></div>
                </div>
            </div>
            <div class="flex justify-end gap-3 pt-4 border-t dark:border-dark-border">
                <button onclick="closeAddCharModal()" class="px-6 py-3 text-sm font-bold border dark:border-dark-border rounded-xl hover:bg-zinc-50 dark:hover:bg-zinc-700 transition-colors text-primary dark:text-dark-text">닫기</button>
                <button onclick="submitMultiAdd()" class="px-6 py-3 text-sm font-bold bg-primary dark:bg-zinc-600 text-white rounded-xl hover:bg-primary-hover dark:hover:bg-zinc-500 transition-colors">선택한 캐릭터 추가</button>
            </div>
        </div>
    </div>

    <!-- 세트 추가/수정 모달 (통합) -->
    <div id="add-set-modal" class="modal">
        <div class="bg-white dark:bg-dark-surface p-8 rounded-2xl shadow-2xl max-w-4xl w-full mx-4 border dark:border-dark-border">
            <h4 id="set-modal-title" class="font-bold text-2xl mb-4 text-primary dark:text-dark-text">새 세트(파티) 구성</h4>
            <p class="text-sm text-zinc-500 dark:text-dark-text-muted mb-6">해당 컨텐츠에 포함된 캐릭터 중 원하는 인원을 선택하여 세트를 만듭니다.</p>
            
            <div class="mb-6">
                <label class="block text-sm font-bold mb-2 text-primary dark:text-dark-text">세트 이름 (비워두면 자동 생성)</label>
                <input id="new-set-name" type="text" placeholder="예: 1군, 업둥벞교" class="w-full border dark:border-dark-border rounded-lg px-4 py-3 outline-none focus:ring-2 focus:ring-zinc-200 dark:focus:ring-zinc-600 bg-white dark:bg-dark-surface dark:text-dark-text">
            </div>

            <div class="grid grid-cols-2 gap-6 mb-8">
                <div>
                    <label class="block text-xs font-bold text-zinc-400 dark:text-dark-text-muted mb-3 uppercase tracking-widest">딜러 선택</label>
                    <div id="set-dealer-selection" class="max-h-[300px] overflow-y-auto space-y-2 border dark:border-dark-border rounded-lg p-4 bg-zinc-50 dark:bg-zinc-800/50"></div>
                </div>
                <div>
                    <label class="block text-xs font-bold text-emerald-500 dark:text-emerald-400 mb-3 uppercase tracking-widest">버퍼 선택</label>
                    <div id="set-buffer-selection" class="max-h-[300px] overflow-y-auto space-y-2 border dark:border-dark-border rounded-lg p-4 bg-zinc-50 dark:bg-zinc-800/50"></div>
                </div>
            </div>

            <div class="flex justify-end gap-3 pt-4 border-t dark:border-dark-border">
                <button onclick="closeAddSetModal()" class="px-6 py-3 text-sm font-bold border dark:border-dark-border rounded-xl hover:bg-zinc-50 dark:hover:bg-zinc-700 transition-colors text-primary dark:text-dark-text">취소</button>
                <button id="set-modal-submit-btn" onclick="submitSetForm()" class="px-6 py-3 text-sm font-bold bg-blue-600 text-white rounded-xl hover:bg-blue-700 transition-colors">세트 생성</button>
            </div>
        </div>
    </div>

    <!-- 던담 불러오기 모달 추가 -->
    <div id="dundam-load-modal" class="modal">
        <div class="bg-white dark:bg-dark-surface p-8 rounded-2xl shadow-2xl max-w-2xl w-full mx-4 border dark:border-dark-border">
            <h4 class="font-bold text-2xl mb-4 text-primary dark:text-dark-text">던담 모험단 캐릭터 불러오기</h4>
            <p class="text-sm text-zinc-500 dark:text-dark-text-muted mb-6">
                던담(dundam.xyz) 모험단 페이지에서 전체 내용을 복사(Ctrl+A 후 ctrl+C)하여 아래에 붙여넣으세요.<br>
            </p>

            <textarea id="dundam-paste-area" rows="10" class="w-full border dark:border-dark-border rounded-lg px-4 py-3 mb-6 outline-none focus:ring-2 focus:ring-zinc-200 dark:focus:ring-zinc-600 bg-zinc-50 dark:bg-zinc-800/50 dark:text-dark-text resize-none font-mono text-sm" placeholder="여기에 붙여넣기..."></textarea>

            <div class="mb-6">
                <p class="font-bold text-sm mb-3 text-primary dark:text-dark-text">이미 등록된 캐릭터 처리 방법 (체크한 항목만 업데이트):</p>
                <div class="flex gap-6">
                    <label class="flex items-center gap-2 cursor-pointer">
                        <input type="checkbox" name="update-option" value="stat" class="w-4 h-4 accent-primary">
                        <span class="text-sm text-primary dark:text-dark-text">수치 업데이트</span>
                    </label>
                    <label class="flex items-center gap-2 cursor-pointer">
                        <input type="checkbox" name="update-option" value="note" class="w-4 h-4 accent-primary">
                        <span class="text-sm text-primary dark:text-dark-text">메모 업데이트</span>
                    </label>
                </div>
            </div>

            <div class="flex justify-end gap-3 pt-4 border-t dark:border-dark-border">
                <button onclick="closeDundamModal()" class="px-6 py-3 text-sm font-bold border dark:border-dark-border rounded-xl hover:bg-zinc-50 dark:hover:bg-zinc-700 transition-colors text-primary dark:text-dark-text">취소</button>
                <button onclick="processDundamLoad()" class="px-6 py-3 text-sm font-bold bg-blue-600 text-white rounded-xl hover:bg-blue-700 transition-colors">분석 및 추가</button>
            </div>
        </div>
    </div>

    <script>
        let state = { 
            characters: [], 
            contents: [], 
            activeContentId: null, 
            isEditMode: false, 
            editingCharId: null,
            editingSetId: null,
            sortMethod: 'desc',
            decimalPlaces: 1, // 소수점 자릿수 상태 추가 (기본값 1)
            darkMode: false
        };

        // --- 메모장 관련 스크립트 시작 ---
        const notepadModal = document.getElementById('notepad-modal');
        const notepadHeader = document.getElementById('notepad-header');
        const notepadContent = document.getElementById('notepad-content');
        const notepadResizer = document.getElementById('notepad-resizer');
        const notepadFontsizeInput = document.getElementById('notepad-fontsize');
        let isNotepadOpen = false;
        let selectedImageWrapper = null; // 이미지 래퍼 선택 상태

        function toggleNotepad() {
            isNotepadOpen = !isNotepadOpen;
            if (isNotepadOpen) {
                notepadModal.classList.remove('hidden');
                loadNotepadState();
                // 처음 열 때 중앙 정렬 (위치 정보가 없을 경우)
                if (!notepadModal.style.top || notepadModal.style.top === '50%') {
                     centerNotepad();
                }
                notepadContent.focus();
            } else {
                // 닫기 전에 선택된 이미지 해제하여 핸들이 저장되지 않도록 함
                deselectImage();
                saveNotepadState();
                notepadModal.classList.add('hidden');
            }
        }

        function centerNotepad() {
             const rect = notepadModal.getBoundingClientRect();
             notepadModal.style.top = `${(window.innerHeight - rect.height) / 2}px`;
             notepadModal.style.left = `${(window.innerWidth - rect.width) / 2}px`;
             notepadModal.style.transform = 'none'; // 기존 중앙 정렬 CSS 해제
        }


        function saveNotepadState() {
            // 저장 전에 선택된 이미지 래퍼 해제 (핸들 포함 저장 방지)
            deselectImage();

            localStorage.setItem('planner_notepad_content', notepadContent.innerHTML);
            localStorage.setItem('planner_notepad_fontsize', notepadFontsizeInput.value);
            if (notepadModal.style.top && notepadModal.style.top !== '50%') {
                localStorage.setItem('planner_notepad_pos_top', notepadModal.style.top);
                localStorage.setItem('planner_notepad_pos_left', notepadModal.style.left);
            }
            if (notepadModal.style.width) {
                 localStorage.setItem('planner_notepad_width', notepadModal.style.width);
                 localStorage.setItem('planner_notepad_height', notepadModal.style.height);
            }
        }

        function loadNotepadState() {
            // 내용 로드
            const savedContent = localStorage.getItem('planner_notepad_content');
            if (savedContent) notepadContent.innerHTML = savedContent;

            // 폰트 크기 로드
            const savedSize = localStorage.getItem('planner_notepad_fontsize') || '24';
            notepadFontsizeInput.value = savedSize;
            notepadContent.style.fontSize = savedSize + 'pt';

            // 위치 로드
            const savedTop = localStorage.getItem('planner_notepad_pos_top');
            const savedLeft = localStorage.getItem('planner_notepad_pos_left');
            if (savedTop && savedLeft) {
                notepadModal.style.top = savedTop;
                notepadModal.style.left = savedLeft;
                notepadModal.style.transform = 'none';
            }

            // 크기 로드
            const savedWidth = localStorage.getItem('planner_notepad_width');
            const savedHeight = localStorage.getItem('planner_notepad_height');
            if(savedWidth && savedHeight) {
                notepadModal.style.width = savedWidth;
                notepadModal.style.height = savedHeight;
            }
        }

        function clearNotepad() {
            if(confirm('메모장 내용을 모두 지우시겠습니까?')) {
                notepadContent.innerHTML = '';
                selectedImageWrapper = null;
                saveNotepadState();
                notepadContent.focus();
            }
        }

        // 폰트 크기 변경 이벤트
        notepadFontsizeInput.addEventListener('change', (e) => {
            let size = parseInt(e.target.value);
            if(isNaN(size) || size < 8) size = 8;
            if(size > 144) size = 144;
            e.target.value = size;
            notepadContent.style.fontSize = size + 'pt';
            saveNotepadState();
        });

        // 내용 변경 시 자동 저장 (타이핑 등)
        notepadContent.addEventListener('input', () => {
             // 내용이 변경되면 선택된 이미지 해제 (구조 변경 대비)
             deselectImage();
             saveNotepadState();
        });

        // 이미지 선택/해제 및 삭제 관련 함수들
        function selectImage(img) {
            deselectImage(); // 기존 선택 해제

            // 래퍼 생성
            const wrapper = document.createElement('span');
            wrapper.className = 'image-resizer-wrapper';
            wrapper.contentEditable = false; // 래퍼 자체는 수정 불가

            // 리사이즈 핸들 생성
            const handle = document.createElement('span');
            handle.className = 'image-resizer-handle';

            // 이미지 교체 (래퍼로 감싸기)
            img.parentNode.insertBefore(wrapper, img);
            wrapper.appendChild(img);
            wrapper.appendChild(handle);

            selectedImageWrapper = wrapper;

            // 핸들에 드래그 리사이즈 이벤트 연결
            handle.addEventListener('mousedown', initResizeImage);
        }

        function deselectImage() {
            if (selectedImageWrapper) {
                const img = selectedImageWrapper.querySelector('img');
                if (img) {
                    // 래퍼 제거하고 이미지만 원래 위치로 복귀
                    selectedImageWrapper.parentNode.insertBefore(img, selectedImageWrapper);
                    selectedImageWrapper.remove();
                }
                selectedImageWrapper = null;
            }
        }

        // 이미지 클릭 시 선택
        notepadContent.addEventListener('click', (e) => {
            if (e.target.tagName === 'IMG') {
                // 이미 선택된 이미지 래퍼 내부의 이미지인지 확인
                if (selectedImageWrapper && selectedImageWrapper.contains(e.target)) return;
                selectImage(e.target);
            } else {
                // 이미지 영역 밖 클릭, 또는 핸들 클릭이 아닐 경우 해제
                if (selectedImageWrapper && !e.target.classList.contains('image-resizer-handle')) {
                     deselectImage();
                }
            }
        });

        // 선택된 이미지 삭제 (Backspace, Delete 키)
        notepadContent.addEventListener('keydown', (e) => {
            if ((e.key === 'Backspace' || e.key === 'Delete')) {
                if (selectedImageWrapper) {
                    e.preventDefault();
                    selectedImageWrapper.remove();
                    selectedImageWrapper = null;
                    saveNotepadState();
                }
            }
        });

        // --- 이미지 드래그 리사이즈 로직 ---
        let isResizingImage = false;
        let startImageX, startImageWidth;
        let activeImage = null;

        function initResizeImage(e) {
            if (!selectedImageWrapper) return;
            isResizingImage = true;
            startImageX = e.clientX;
            activeImage = selectedImageWrapper.querySelector('img');
            startImageWidth = activeImage.offsetWidth;
            
            e.preventDefault(); // 텍스트 선택 방지
            e.stopPropagation(); // 이벤트 전파 방지

            document.addEventListener('mousemove', doResizeImage);
            document.addEventListener('mouseup', stopResizeImage);
        }

        function doResizeImage(e) {
            if (!isResizingImage || !activeImage) return;
            const newWidth = startImageWidth + (e.clientX - startImageX);
            // 최소 크기 제한 (예: 50px)
            if (newWidth > 50) {
                activeImage.style.width = newWidth + 'px';
                activeImage.style.height = 'auto';
            }
        }

        function stopResizeImage() {
            if (isResizingImage) {
                isResizingImage = false;
                activeImage = null;
                document.removeEventListener('mousemove', doResizeImage);
                document.removeEventListener('mouseup', stopResizeImage);
                // 크기 변경 후 저장 (저장 시 선택 해제됨)
                saveNotepadState();
            }
        }
        // --- 이미지 드래그 리사이즈 로직 끝 ---


        // 드래그 앤 드롭 구현 (메모장 이동)
        let isDragging = false;
        let dragOffsetX, dragOffsetY;

        notepadHeader.addEventListener('mousedown', (e) => {
            // 입력 필드나 버튼 클릭 시 드래그 방지
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON' || e.target.closest('button')) return;
            isDragging = true;
            const rect = notepadModal.getBoundingClientRect();
            dragOffsetX = e.clientX - rect.left;
            dragOffsetY = e.clientY - rect.top;
            notepadModal.style.transform = 'none'; // 드래그 시작 시 transform 해제
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                let newX = e.clientX - dragOffsetX;
                let newY = e.clientY - dragOffsetY;

                // 화면 밖으로 나가지 않게 제한
                const maxX = window.innerWidth - notepadModal.offsetWidth;
                const maxY = window.innerHeight - notepadModal.offsetHeight;
                newX = Math.max(0, Math.min(newX, maxX));
                newY = Math.max(0, Math.min(newY, maxY));

                notepadModal.style.left = newX + 'px';
                notepadModal.style.top = newY + 'px';
            }
        });

        document.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                saveNotepadState();
            }
        });

        // 리사이즈 구현 (메모장 크기 조절)
        let isResizing = false;
        let resizeStartX, resizeStartY, startWidth, startHeight;

        notepadResizer.addEventListener('mousedown', (e) => {
            isResizing = true;
            resizeStartX = e.clientX;
            resizeStartY = e.clientY;
            startWidth = notepadModal.offsetWidth;
            startHeight = notepadModal.offsetHeight;
            e.preventDefault(); // 텍스트 선택 방지
        });

        document.addEventListener('mousemove', (e) => {
            if (isResizing) {
                const newWidth = startWidth + (e.clientX - resizeStartX);
                const newHeight = startHeight + (e.clientY - resizeStartY);
                notepadModal.style.width = newWidth + 'px';
                notepadModal.style.height = newHeight + 'px';
            }
        });

        document.addEventListener('mouseup', () => {
            if (isResizing) {
                isResizing = false;
                saveNotepadState();
            }
        });
        // --- 메모장 관련 스크립트 끝 ---


        function init() {
            const saved = localStorage.getItem('party_data_v6');
            if (saved) { 
                state = { ...state, ...JSON.parse(saved) };
                state.isEditMode = false;
                state.editingSetId = null;
                state.contents.forEach(c => { if(!c.sets) c.sets = []; });
                if (!state.sortMethod) state.sortMethod = 'desc';
                if (state.decimalPlaces === undefined) state.decimalPlaces = 1; // 초기값 설정
                if (state.darkMode === undefined) state.darkMode = false;
            }
            document.getElementById('sort-select').value = state.sortMethod;
            document.getElementById('decimal-select').value = state.decimalPlaces; // 소수점 선택 셀렉트 초기화
            
            applyDarkMode();
            render();
            // 메모장 상태 로드는 toggleNotepad() 호출 시 수행
        }

        function save() {
            localStorage.setItem('party_data_v6', JSON.stringify(state));
        }

        function toggleDarkMode() {
            state.darkMode = !state.darkMode;
            applyDarkMode();
            save();
        }

        function applyDarkMode() {
            if (state.darkMode) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        }

        // 캐릭터 관리 기능
        function addCharacter() {
            const nameInput = document.getElementById('char-name');
            const statInput = document.getElementById('char-stat');
            const noteInput = document.getElementById('char-note');
            
            const name = nameInput.value.trim();
            const stat = statInput.value.trim();
            const note = noteInput.value.trim();
            const type = document.getElementById('char-type').value;
            
            if (!name || !stat) return;
            if (state.characters.some(c => c.name === name)) return alert('중복된 닉네임입니다.');
            
            state.characters.push({ id: 'char_' + Date.now(), name, stat: Number(stat), note, type });
            nameInput.value = ''; statInput.value = ''; noteInput.value = '';
            save();
            render();
        }

        function startInlineEdit(id) {
            state.editingCharId = id;
            renderCharacters();
        }

        function cancelInlineEdit() {
            state.editingCharId = null;
            renderCharacters();
        }

        function submitInlineEdit(id) {
            const char = state.characters.find(c => c.id === id);
            const name = document.getElementById(`edit-name-${id}`).value.trim();
            const stat = document.getElementById(`edit-stat-${id}`).value.trim();
            const note = document.getElementById(`edit-note-${id}`).value.trim();
            const type = document.getElementById(`edit-type-${id}`).value;

            if (!name || !stat) return;

            if (state.characters.some(c => c.id !== id && c.name === name)) {
                alert('중복된 닉네임입니다.');
                return;
            }

            char.name = name;
            char.stat = Number(stat);
            char.note = note;
            char.type = type;
            state.editingCharId = null;
            save();
            render();
        }

        function deleteCharacter(id) {
            if(!confirm('전체 목록에서 이 캐릭터를 삭제하시겠습니까? 관련 세트에서도 제외됩니다.')) return;
            state.characters = state.characters.filter(c => c.id !== id);
            state.contents.forEach(ct => {
                ct.contentCharacters = ct.contentCharacters.filter(cc => cc.charId !== id);
                if (ct.sets) {
                    ct.sets.forEach(s => {
                        s.charIds = s.charIds.filter(cid => cid !== id);
                    });
                }
            });
            save();
            render();
        }

        function changeSortMethod(method) {
            state.sortMethod = method;
            save();
            render();
        }

        function changeDecimalPlaces(value) {
            state.decimalPlaces = parseInt(value, 10);
            save();
            render();
        }

        function getSortedCharacters() {
            const chars = [...state.characters];
            switch (state.sortMethod) {
                case 'asc':
                    return chars.sort((a, b) => a.stat - b.stat);
                case 'name':
                    return chars.sort((a, b) => a.name.localeCompare(b.name, 'ko'));
                case 'desc':
                default:
                    return chars.sort((a, b) => b.stat - a.stat);
            }
        }

        // 컨텐츠 관리 기능
        function addContent() {
            const name = document.getElementById('new-content-name').value.trim();
            if (!name) return;
            const id = 'cont_' + Date.now();
            state.contents.push({ id, name, contentCharacters: [], sets: [] });
            state.activeContentId = id;
            document.getElementById('new-content-name').value = '';
            save();
            render();
        }

        function deleteContent() {
            if (!state.activeContentId) return;
            const content = state.contents.find(c => c.id === state.activeContentId);
            if (!content) return;
            if (!confirm(`'${content.name}' 컨텐츠를 삭제하시겠습니까?`)) return;
            
            state.contents = state.contents.filter(c => c.id !== state.activeContentId);
            state.activeContentId = state.contents.length > 0 ? state.contents[0].id : null;
            save();
            render();
        }

        function renameContent() {
            const content = state.contents.find(c => c.id === state.activeContentId);
            if (!content) return;
            const newName = prompt('수정할 이름을 입력하세요', content.name);
            if (newName && newName.trim()) { 
                content.name = newName.trim(); 
                save();
                render();
            }
        }

        function moveContent(direction) {
            if (!state.activeContentId) return;
            const index = state.contents.findIndex(c => c.id === state.activeContentId);
            if (index === -1) return;

            const targetIndex = index + direction;
            if (targetIndex < 0 || targetIndex >= state.contents.length) return;

            const temp = state.contents[index];
            state.contents[index] = state.contents[targetIndex];
            state.contents[targetIndex] = temp;
            save();
            render();
        }

        function toggleCharClear(charId) {
            if (state.isEditMode) return;
            const content = state.contents.find(c => c.id === state.activeContentId);
            if (!content) return;
            const cc = content.contentCharacters.find(cc => cc.charId === charId);
            if (cc) { 
                cc.isCleared = !cc.isCleared; 
                save();
                renderContentArea();
                renderDashboard();
            }
        }

        function toggleSetClear(setId) {
            if (state.isEditMode) return;
            const content = state.contents.find(c => c.id === state.activeContentId);
            if (!content) return;
            const set = content.sets.find(s => s.id === setId);
            if (!set) return;

            const members = content.contentCharacters.filter(cc => set.charIds.includes(cc.charId));
            const allCleared = members.length > 0 && members.every(m => m.isCleared);
            
            members.forEach(m => m.isCleared = !allCleared);
            save();
            renderContentArea();
            renderDashboard();
        }

        function toggleEditMode() { 
            state.isEditMode = !state.isEditMode; 
            renderContentArea();
        }

        // 모달 관리
        function openAddCharModal() {
            const content = state.contents.find(c => c.id === state.activeContentId);
            if (!content) return;
            const mD = document.getElementById('modal-dealer-list');
            const mB = document.getElementById('modal-buffer-list');
            
            // 모달 열릴 때 전체 선택 버튼 초기화
            document.getElementById('toggle-all-dealer-btn').innerText = '전체 선택';
            document.getElementById('toggle-all-buffer-btn').innerText = '전체 선택';
            
            let dealerHtml = '';
            let bufferHtml = '';
            
            const availableChars = getSortedCharacters()
                .filter(char => !content.contentCharacters.some(cc => cc.charId === char.id));

            availableChars.forEach(char => {
                const noteDisplay = char.note ? ` ${char.note}` : '';
                // 수치 포맷팅 적용
                const formattedStat = formatStat(char.stat, char.type);
                const html = `
                    <label class="flex items-center justify-between p-3 rounded-lg border dark:border-dark-border cursor-pointer bg-white dark:bg-dark-surface">
                        <div class="flex items-center gap-3">
                            <input type="checkbox" name="multi-char-select" value="${char.id}" data-char-type="${char.type}" class="w-4 h-4 accent-primary">
                            <span class="font-bold text-sm text-primary dark:text-dark-text truncate">${char.name} <span class="text-zinc-400 dark:text-dark-text-muted">${formattedStat}${noteDisplay}</span></span>
                        </div>
                    </label>`;
                char.type === 'dealer' ? dealerHtml += html : bufferHtml += html;
            });

            mD.innerHTML = dealerHtml;
            mB.innerHTML = bufferHtml;
            document.getElementById('add-char-modal').classList.add('active');
        }

        function toggleAllChars(type) {
            const containerId = type === 'dealer' ? 'modal-dealer-list' : 'modal-buffer-list';
            const btnId = type === 'dealer' ? 'toggle-all-dealer-btn' : 'toggle-all-buffer-btn';
            const container = document.getElementById(containerId);
            const btn = document.getElementById(btnId);
            const checkboxes = container.querySelectorAll(`input[name="multi-char-select"][data-char-type="${type}"]`);
            
            const isAllSelected = btn.innerText === '전체 해제';
            
            checkboxes.forEach(cb => {
                cb.checked = !isAllSelected;
            });

            btn.innerText = isAllSelected ? '전체 선택' : '전체 해제';
        }

        function submitMultiAdd() {
            const content = state.contents.find(c => c.id === state.activeContentId);
            const selected = document.querySelectorAll('input[name="multi-char-select"]:checked');
            selected.forEach(cb => content.contentCharacters.push({ charId: cb.value, isCleared: false }));
            closeAddCharModal();
            save();
            render();
        }

        function removeCharFromContent(charId) {
            const content = state.contents.find(c => c.id === state.activeContentId);
            if (!content) return;
            content.contentCharacters = content.contentCharacters.filter(cc => cc.charId !== charId);
            if (content.sets) {
                content.sets.forEach(s => {
                    s.charIds = s.charIds.filter(id => id !== charId);
                });
            }
            save();
            renderContentArea();
            renderDashboard();
        }

        function openSetModal(setId = null) {
            const content = state.contents.find(c => c.id === state.activeContentId);
            if (!content) return;
            
            state.editingSetId = setId;
            
            const dContainer = document.getElementById('set-dealer-selection');
            const bContainer = document.getElementById('set-buffer-selection');
            const nameInput = document.getElementById('new-set-name');
            const modalTitle = document.getElementById('set-modal-title');
            const submitBtn = document.getElementById('set-modal-submit-btn');

            let dealerHtml = '';
            let bufferHtml = '';
            
            let targetSet = null;
            if (setId) {
                targetSet = content.sets.find(s => s.id === setId);
            }

            if (targetSet) {
                modalTitle.innerText = "세트 구성 수정";
                submitBtn.innerText = "세트 수정 완료";
                nameInput.value = targetSet.name;
            } else {
                modalTitle.innerText = "새 세트(파티) 구성";
                submitBtn.innerText = "세트 생성";
                nameInput.value = '';
            }
            
            const sortedContentChars = content.contentCharacters
                .map(cc => state.characters.find(c => c.id === cc.charId))
                .filter(c => c);

            let sortedChars;
            switch (state.sortMethod) {
                case 'asc': sortedChars = sortedContentChars.sort((a, b) => a.stat - b.stat); break;
                case 'name': sortedChars = sortedContentChars.sort((a, b) => a.name.localeCompare(b.name, 'ko')); break;
                case 'desc': default: sortedChars = sortedContentChars.sort((a, b) => b.stat - a.stat); break;
            }
            
            sortedChars.forEach(char => {
                const isChecked = targetSet && targetSet.charIds.includes(char.id);
                const noteDisplay = char.note ? ` ${char.note}` : '';
                // 수치 포맷팅 적용
                const formattedStat = formatStat(char.stat, char.type);
                
                const html = `
                    <label class="flex items-center justify-between p-3 rounded-lg border dark:border-dark-border bg-white dark:bg-dark-surface cursor-pointer">
                        <div class="flex items-center gap-3">
                            <input type="checkbox" name="set-member-select" value="${char.id}" class="w-4 h-4 accent-blue-600" ${isChecked ? 'checked' : ''}>
                            <span class="font-bold text-sm text-primary dark:text-dark-text truncate">${char.name} <span class="text-zinc-400 dark:text-dark-text-muted">${formattedStat}${noteDisplay}</span></span>
                        </div>
                    </label>
                `;
                char.type === 'dealer' ? dealerHtml += html : bufferHtml += html;
            });

            dContainer.innerHTML = dealerHtml;
            bContainer.innerHTML = bufferHtml;
            document.getElementById('add-set-modal').classList.add('active');
        }

        function submitSetForm() {
            const content = state.contents.find(c => c.id === state.activeContentId);
            const nameInput = document.getElementById('new-set-name');
            const selected = Array.from(document.querySelectorAll('input[name="set-member-select"]:checked')).map(cb => cb.value);
            
            if (selected.length < 1) return alert('캐릭터를 선택해주세요.');

            let setName = nameInput.value.trim();

            if (state.editingSetId) {
                const set = content.sets.find(s => s.id === state.editingSetId);
                if (set) {
                    if (!setName) setName = set.name;
                    set.name = setName;
                    set.charIds = selected;
                }
            } else {
                if (!setName) {
                    const currentSetCount = (content.sets || []).length;
                    setName = (currentSetCount + 1) + "파티";
                }
                if (!content.sets) content.sets = [];
                content.sets.push({
                    id: 'set_' + Date.now(),
                    name: setName,
                    charIds: selected
                });
            }
            
            nameInput.value = '';
            closeAddSetModal();
            state.editingSetId = null;
            save();
            renderContentArea();
        }

        function deleteSet(setId) {
            const content = state.contents.find(c => c.id === state.activeContentId);
            if (!content) return;
            content.sets = content.sets.filter(s => s.id !== setId);
            save();
            renderContentArea();
        }

        function confirmResetAll() {
            if (confirm('모든 컨텐츠의 클리어 체크를 해제할까요?')) {
                state.contents.forEach(c => c.contentCharacters.forEach(cc => cc.isCleared = false));
                save();
                render();
            }
        }

        // --- 던담 불러오기 관련 로직 시작 ---

        function openDundamModal() {
            // 모달 열 때 기본적으로 체크박스를 선택 상태로 설정
            document.querySelectorAll('input[name="update-option"]').forEach(cb => cb.checked = true);
            document.getElementById('dundam-load-modal').classList.add('active');
        }

        function closeDundamModal() {
            document.getElementById('dundam-load-modal').classList.remove('active');
            document.getElementById('dundam-paste-area').value = '';
            // 체크박스 초기화
            document.querySelectorAll('input[name="update-option"]').forEach(cb => cb.checked = false);
        }

        function parseNumberStr(str) {
            // 쉼표 제거
            str = str.replace(/,/g, '');
            
            // --- 수정된 로직 시작 ---
            // 문자열에서 연속된 숫자들을 모두 추출합니다. 단위("억", "만" 등)는 무시됩니다.
            const numbers = str.match(/\d+/g);

            if (numbers) {
                if (numbers.length >= 2) {
                    // 숫자가 2개 이상 발견되면, 첫 번째 숫자와 두 번째 숫자를 '.'으로 연결하여 하나의 실수로 만듭니다.
                    // 예: "548 억 729 만" -> ["548", "729"] -> 548.729
                    // 예: "SomeUnit 123 OtherUnit 456" -> ["123", "456"] -> 123.456
                    return parseFloat(`${numbers[0]}.${numbers[1]}`);
                } else if (numbers.length === 1) {
                    // 숫자가 1개만 발견되면 정수로 반환합니다. (버퍼 점수 등)
                    // 예: "6824090" -> ["6824090"] -> 6824090
                    return parseInt(numbers[0], 10);
                }
            }
            // --- 수정된 로직 끝 ---

            // Case 4: 소수점이 있는 숫자 형태 (기존 로직 유지)
            if (/^\d+(\.\d+)?$/.test(str)) {
                return parseFloat(str);
            }

            return 0;
        }

        function parseDundamText(text) {
            const lines = text.split('\n').map(l => l.trim()).filter(l => l);
            const parsedChars = [];
            let adventureName = '';

            // 모험단 이름 찾기 (예: 7~8번째 줄 근처 "모험단" 텍스트 다음 줄)
            for (let i = 0; i < Math.min(lines.length, 20); i++) {
                if (lines[i] === '모험단' && i + 1 < lines.length) {
                    adventureName = lines[i + 1];
                    break;
                }
            }

            if (!adventureName) {
                alert('모험단 이름을 찾을 수 없습니다. 올바른 데이터를 붙여넣었는지 확인해주세요.');
                return [];
            }

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                // 모험단 이름으로 끝나는 줄 찾기
                if (line.endsWith(adventureName) && line.length > adventureName.length) {
                    const charName = line.substring(0, line.length - adventureName.length);
                    let type = 'dealer'; // 기본값
                    let stat = 0;
                    let note = '';

                    // 다음 몇 줄을 검사하여 수치 정보 찾기
                    let j = i + 1;
                     // 명성치 줄 건너뛰기 (숫자로만 구성된 줄)
                     if (j < lines.length && /^\d+$/.test(lines[j])) {
                        j++;
                    }

                    if (j < lines.length) {
                        let statLine = lines[j];

                        if (statLine.startsWith('버프점수')) {
                            type = 'buffer';
                            stat = parseNumberStr(statLine.replace('버프점수', ''));
                        } else if (statLine.startsWith('4인')) {
                            // "4인" 수치가 있는 경우 (우선순위 높음)
                            type = 'dealer';
                            stat = parseNumberStr(statLine.replace('4인', ''));
                            // 다음 줄에 "랭킹" 수치가 있는지 확인하여 메모로 저장
                            if (j + 1 < lines.length) {
                                const nextLine = lines[j+1];
                                if (nextLine.startsWith('랭킹')) {
                                    const secondaryStat = parseNumberStr(nextLine.replace('랭킹', ''));
                                    note = secondaryStat.toString();
                                }
                            }
                        } else if (statLine.startsWith('랭킹')) {
                            // "랭킹" 수치만 있는 경우
                            type = 'dealer';
                            stat = parseNumberStr(statLine.replace('랭킹', ''));
                        }
                    }

                    if (stat > 0) {
                        parsedChars.push({ name: charName, type, stat, note });
                    }
                }
            }
            return parsedChars;
        }

        function processDundamLoad() {
            const text = document.getElementById('dundam-paste-area').value;
            const updateOptions = Array.from(document.querySelectorAll('input[name="update-option"]:checked')).map(cb => cb.value);
            const updateStat = updateOptions.includes('stat');
            const updateNote = updateOptions.includes('note');

            if (!text) { alert('붙여넣은 내용이 없습니다.'); return; }

            const parsedResults = parseDundamText(text);

            if (parsedResults.length === 0) {
                // parseDundamText 내부에서 얼럿을 띄우므로 여기선 리턴만 함
                return;
            }

            let addedCount = 0;
            let updatedCount = 0;
            let skippedCount = 0;

            parsedResults.forEach(parsedChar => {
                const existingCharIndex = state.characters.findIndex(c => c.name === parsedChar.name);

                if (existingCharIndex !== -1) {
                    // 이미 존재하는 캐릭터
                    let isUpdated = false;
                    if (updateStat) {
                        state.characters[existingCharIndex].stat = parsedChar.stat;
                        state.characters[existingCharIndex].type = parsedChar.type;
                        isUpdated = true;
                    }
                    if (updateNote && parsedChar.note) {
                         state.characters[existingCharIndex].note = parsedChar.note;
                         isUpdated = true;
                    }

                    if (isUpdated) {
                        updatedCount++;
                    } else {
                        skippedCount++;
                    }
                } else {
                    // 새 캐릭터 추가
                    state.characters.push({
                        id: 'char_' + Date.now() + Math.random().toString(36).substr(2, 5),
                        name: parsedChar.name,
                        stat: parsedChar.stat,
                        type: parsedChar.type,
                        note: parsedChar.note
                    });
                    addedCount++;
                }
            });

            save();
            render();
            closeDundamModal();
            alert(`처리 완료:\n- 추가됨: ${addedCount}명\n- 업데이트됨: ${updatedCount}명\n- 건너뜀: ${skippedCount}명`);
        }
        // --- 던담 불러오기 관련 로직 끝 ---

        // --- 수치 포맷팅 헬퍼 함수 수정 ---
        function formatStat(stat, type) {
            if (type === 'dealer') {
                // 딜러: 선택된 소수점 자릿수만큼 버림 처리
                const value = Number(stat);
                const power = Math.pow(10, state.decimalPlaces);
                const flooredValue = Math.floor(value * power) / power;
                
                // .toFixed()를 사용하여 지정된 소수점 자릿수로 포맷팅
                return flooredValue.toFixed(state.decimalPlaces);
            } else {
                // 버퍼: 3자리마다 콤마 찍기 (예: 6824090 -> 6,824,090)
                return Number(stat).toLocaleString('ko-KR');
            }
        }
        // ---------------------------------


        // 렌더링 함수들
        function render() {
            renderDashboard();
            renderCharacters();
            renderTabs();
            renderContentArea();
        }

        function renderDashboard() {
            const grid = document.getElementById('dashboard-grid');
            let html = '';
            state.contents.forEach(c => {
                const total = c.contentCharacters.length;
                const cleared = c.contentCharacters.filter(cc => cc.isCleared).length;
                const ratio = total === 0 ? 0 : Math.round((cleared/total)*100);
                
                html += `
                    <div class="bg-white dark:bg-dark-surface p-4 rounded-xl border dark:border-dark-border shadow-sm cursor-pointer hover:border-zinc-400 dark:hover:border-zinc-500 transition-colors" onclick="state.activeContentId = '${c.id}'; state.isEditMode = false; render();">
                        <div class="flex justify-between mb-2 text-xs font-bold">
                            <span class="truncate pr-2 text-primary dark:text-dark-text">${c.name}</span>
                            <span class="text-zinc-400 dark:text-dark-text-muted font-mono shrink-0">${cleared}/${total}</span>
                        </div>
                        <div class="status-bar-bg"><div class="status-bar-fill" style="width:${ratio}%"></div></div>
                    </div>`;
            });
            grid.innerHTML = html;
        }

        function renderCharacters() {
            const dList = document.getElementById('dealer-list');
            const bList = document.getElementById('buffer-list');
            
            let dealerHtml = '';
            let bufferHtml = '';

            getSortedCharacters().forEach(char => {
                const isEditing = state.editingCharId === char.id;
                const noteDisplay = char.note ? ` ${char.note}` : '';
                
                let charHtml = '';
                if (isEditing) {
                     charHtml = `
                        <div class="p-3 border rounded-lg editing-char-box">
                            <div class="flex flex-col gap-2 mb-2">
                                <input id="edit-name-${char.id}" type="text" value="${char.name}" class="w-full border dark:border-dark-border rounded px-2 py-1 text-sm font-bold outline-none text-primary dark:text-dark-text bg-white dark:bg-dark-surface">
                                <div class="flex gap-2">
                                    <input id="edit-stat-${char.id}" type="number" value="${char.stat}" class="w-1/2 border dark:border-dark-border rounded px-2 py-1 text-xs outline-none text-primary dark:text-dark-text bg-white dark:bg-dark-surface" placeholder="수치">
                                    <input id="edit-note-${char.id}" type="text" value="${char.note || ''}" class="w-1/2 border dark:border-dark-border rounded px-2 py-1 text-xs outline-none text-primary dark:text-dark-text bg-white dark:bg-dark-surface" placeholder="메모">
                                </div>
                                <select id="edit-type-${char.id}" class="w-full border dark:border-dark-border rounded px-2 py-1 text-xs outline-none text-primary dark:text-dark-text bg-white dark:bg-dark-surface">
                                    <option value="dealer" ${char.type === 'dealer' ? 'selected' : ''}>딜러</option>
                                    <option value="buffer" ${char.type === 'buffer' ? 'selected' : ''}>버퍼</option>
                                </select>
                            </div>
                            <div class="flex gap-1">
                                <button onclick="submitInlineEdit('${char.id}')" class="flex-1 bg-primary dark:bg-zinc-700 text-white text-[10px] py-1 rounded hover:bg-primary-hover dark:hover:bg-zinc-600 transition-colors">저장</button>
                                <button onclick="cancelInlineEdit()" class="flex-1 bg-white dark:bg-dark-surface border dark:border-dark-border text-primary dark:text-dark-text text-[10px] py-1 rounded hover:bg-zinc-50 dark:hover:bg-zinc-700 transition-colors">취소</button>
                            </div>
                        </div>
                    `;
                } else {
                    // 수치 포맷팅 적용
                    const formattedStat = formatStat(char.stat, char.type);
                    charHtml = `
                        <div class="flex flex-col p-3 border dark:border-dark-border rounded-lg bg-white dark:bg-dark-surface hover:border-zinc-300 dark:hover:border-zinc-500 transition-colors group relative border-f4f4f5">
                            <div class="flex items-center gap-1.5 overflow-hidden text-sm font-bold">
                                <span class="truncate text-primary dark:text-dark-text">${char.name}</span>
                                <span class="text-zinc-400 dark:text-dark-text-muted">${formattedStat}${noteDisplay}</span>
                            </div>
                            <div class="absolute top-2 right-2 flex gap-0.5 opacity-0 group-hover:opacity-100 transition-opacity bg-white dark:bg-dark-surface pl-1 rounded-bl-lg hover-actions">
                                <button onclick="startInlineEdit('${char.id}')" class="p-1 hover:bg-zinc-100 dark:hover:bg-zinc-700 rounded text-zinc-400 dark:text-zinc-500 transition-colors"><svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"></path></svg></button>
                                <button onclick="deleteCharacter('${char.id}')" class="p-1 hover:bg-red-50 dark:hover:bg-red-900/30 rounded text-red-300 dark:text-red-400 hover:text-red-500 transition-colors"><svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></button>
                            </div>
                        </div>
                    `;
                }
                char.type === 'dealer' ? dealerHtml += charHtml : bufferHtml += charHtml;
            });

            dList.innerHTML = dealerHtml;
            bList.innerHTML = bufferHtml;
        }

        function renderTabs() {
            const container = document.getElementById('content-tabs');
            
            let tabsHtml = '';
            state.contents.forEach((c, idx) => {
                const active = state.activeContentId === c.id;
                const wrapperClass = `tab-btn px-5 py-3 rounded-xl text-base font-bold transition-colors flex items-center gap-2.5 cursor-pointer ${active ? 'bg-primary dark:bg-zinc-700 text-white shadow-md tab-active' : 'bg-zinc-100 dark:bg-zinc-800 text-zinc-500 dark:text-zinc-400 hover:bg-zinc-200 dark:hover:bg-zinc-700 tab-inactive'}`;
                const btnClass = `move-btn transition-colors ${active ? 'text-zinc-400 dark:text-zinc-300' : 'text-zinc-300 dark:text-zinc-500'}`;
                
                const leftBtnHidden = idx === 0 ? 'invisible' : '';
                const rightBtnHidden = idx === state.contents.length - 1 ? 'invisible' : '';

                tabsHtml += `
                    <div class="${wrapperClass}" onclick="state.activeContentId = '${c.id}'; state.isEditMode = false; render();">
                        <button class="${btnClass} ${leftBtnHidden}" onclick="event.stopPropagation(); moveContent(-1);">
                            <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M15 19l-7-7 7-7"></path></svg>
                        </button>
                        <span class="whitespace-nowrap">${c.name}</span>
                        <button class="${btnClass} ${rightBtnHidden}" onclick="event.stopPropagation(); moveContent(1);">
                            <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M9 5l7 7-7 7"></path></svg>
                        </button>
                    </div>
                `;
            });
            container.innerHTML = tabsHtml;
        }

        function renderContentArea() {
            const dGrid = document.getElementById('dealer-grid');
            const bGrid = document.getElementById('buffer-grid');
            const sGrid = document.getElementById('sets-grid');
            const container = document.getElementById('content-grid-container');
            const setsContainer = document.getElementById('content-sets-container');
            const empty = document.getElementById('empty-content-msg');
            const content = state.contents.find(c => c.id === state.activeContentId);

            if (!content) {
                container.classList.add('hidden'); setsContainer.classList.add('hidden'); empty.classList.remove('hidden');
                document.getElementById('party-controls').classList.add('hidden');
                document.getElementById('content-edit-tools').classList.add('hidden');
                return;
            }

            container.classList.remove('hidden'); setsContainer.classList.remove('hidden'); empty.classList.add('hidden');
            document.getElementById('party-controls').classList.remove('hidden');
            document.getElementById('content-edit-tools').classList.remove('hidden');
            document.getElementById('current-content-title').innerText = content.name;
            
            const editBtn = document.getElementById('edit-mode-btn');
            editBtn.innerText = state.isEditMode ? '수정 완료' : '수정 모드';
            editBtn.className = `px-5 py-2 border rounded-lg text-sm font-bold transition-colors shadow-sm ${state.isEditMode ? 'bg-orange-500 border-orange-500 text-white dark:bg-orange-600 dark:border-orange-600' : 'bg-white dark:bg-dark-surface border-zinc-200 dark:border-dark-border text-primary dark:text-dark-text hover:bg-zinc-50 dark:hover:bg-zinc-700'}`;

            let setsHtml = '';
            if (content.sets && content.sets.length > 0) {
                content.sets.forEach(set => {
                    const members = content.contentCharacters.filter(cc => set.charIds.includes(cc.charId));
                    const allCleared = members.length > 0 && members.every(m => m.isCleared);
                    const setCardClass = `set-card p-4 transition-colors cursor-pointer relative bg-fafafa dark:bg-dark-surface border-e4e4e7 dark:border-dark-border ${allCleared ? 'cleared' : ''} ${state.isEditMode ? 'border-dashed border-zinc-400 dark:border-zinc-500' : 'border'}`;
                    const onClickAttr = !state.isEditMode ? `onclick="toggleSetClear('${set.id}')"` : '';

                    let membersHtml = members.map(m => {
                        const char = state.characters.find(c => c.id === m.charId);
                        if(!char) return '';

                        const typePrefix = char.type === 'dealer' 
                            ? '<span class="text-zinc-400 dark:text-dark-text-muted mr-0.5 font-medium">(딜)</span>' 
                            : '<span class="text-emerald-500 dark:text-emerald-400 mr-0.5 font-medium">(벞)</span>';

                        const clearedClass = m.isCleared ? 'bg-emerald-50 dark:bg-emerald-900/30 border-emerald-200 dark:border-emerald-800 text-emerald-700 dark:text-emerald-400' : 'bg-white dark:bg-dark-surface shadow-sm border-zinc-100 dark:border-dark-border';
                        const noteDisplay = char.note ? ` ${char.note}` : '';
                        // 수치 포맷팅 적용
                        const formattedStat = formatStat(char.stat, char.type);

                        return `
                            <div class="flex items-center justify-center gap-1.5 p-2 rounded border ${clearedClass} text-sm font-bold">
                                <span class="truncate ${m.isCleared ? '' : 'text-primary dark:text-dark-text'}">${typePrefix}${char.name}</span>
                                <span class="${m.isCleared ? 'text-emerald-600 dark:text-emerald-300' : 'text-zinc-400 dark:text-dark-text-muted'}">${formattedStat}${noteDisplay}</span>
                            </div>
                        `;
                    }).join('');

                    const setNameHtml = `<h4 class="font-bold text-sm text-primary dark:text-dark-text">${set.name}</h4>`;

                    let actionButtons = '';
                    if (state.isEditMode) {
                        actionButtons = `
                            <button onclick="event.stopPropagation(); openSetModal('${set.id}')" class="text-blue-500 hover:text-blue-700 dark:text-blue-400 dark:hover:text-blue-300 font-bold text-xs bg-blue-50 dark:bg-blue-900/20 px-2 py-0.5 rounded mr-1 transition-colors">수정</button>
                            <button onclick="event.stopPropagation(); deleteSet('${set.id}')" class="text-red-400 hover:text-red-600 dark:text-red-300 dark:hover:text-red-500 font-bold text-xs bg-red-50 dark:bg-red-900/20 px-2 py-0.5 rounded transition-colors">삭제</button>
                        `;
                    } else if (allCleared) {
                        actionButtons = '<span class="text-[10px] font-black text-emerald-700 dark:text-emerald-300 bg-emerald-100 dark:bg-emerald-900/50 px-2 py-0.5 rounded">ALL CLEAR</span>';
                    }

                    setsHtml += `
                        <div class="${setCardClass}" ${onClickAttr}>
                            <div class="flex justify-between items-center mb-3 gap-2">
                                ${setNameHtml}
                                <div class="flex items-center gap-2 shrink-0">
                                    ${actionButtons}
                                </div>
                            </div>
                            <div class="flex flex-wrap gap-1.5">
                                ${membersHtml || '<span class="w-full text-xs text-zinc-400 dark:text-dark-text-muted italic text-center py-2">멤버 없음</span>'}
                            </div>
                        </div>
                    `;
                });
            } else {
                setsHtml = '<div class="col-span-full py-10 text-center text-zinc-300 dark:text-zinc-500 text-sm border-2 border-dashed dark:border-dark-border rounded-xl bg-zinc-50 dark:bg-zinc-800/50">생성된 세트가 없습니다.</div>';
            }
            sGrid.innerHTML = setsHtml;

            let dealerGridHtml = '';
            let bufferGridHtml = '';
            const ccList = content.contentCharacters.map(cc => ({ ...cc, char: state.characters.find(c => c.id === cc.charId) })).filter(i => i.char);

            ccList.forEach(item => {
                const { char, isCleared } = item;
                const charCardClass = `char-card card p-4 flex items-center justify-between shadow-sm bg-white dark:bg-dark-surface border-f4f4f5 dark:border-dark-border ${isCleared ? 'cleared' : ''} ${state.isEditMode ? 'border-dashed border-zinc-300 dark:border-zinc-500' : 'border'}`;
                const noteDisplay = char.note ? ` ${char.note}` : '';
                // 수치 포맷팅 적용
                const formattedStat = formatStat(char.stat, char.type);

                const charHtml = `
                    <div class="${charCardClass}" onclick="toggleCharClear('${char.id}')">
                        <div class="flex items-center gap-2 overflow-hidden text-base font-bold">
                            <span class="truncate ${isCleared ? '' : 'text-primary dark:text-dark-text'}">${char.name}</span>
                            <span class="${isCleared ? 'text-emerald-600 dark:text-emerald-300' : 'text-zinc-400 dark:text-dark-text-muted'}">${formattedStat}${noteDisplay}</span>
                        </div>
                        <div class="flex items-center gap-2">
                            ${state.isEditMode ? `
                                <button onclick="event.stopPropagation(); removeCharFromContent('${char.id}')" class="text-red-400 hover:text-red-600 dark:text-red-300 dark:hover:text-red-500 font-bold p-1 transition-colors">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                                </button>
                            ` : (isCleared ? '<span class="text-[10px] font-black text-emerald-700 dark:text-emerald-300 tracking-widest bg-emerald-50 dark:bg-emerald-900/50 px-2 py-1 rounded">CLEAR</span>' : '')}
                        </div>
                    </div>
                `;
                char.type === 'dealer' ? dealerGridHtml += charHtml : bufferGridHtml += charHtml;
            });
            dGrid.innerHTML = dealerGridHtml;
            bGrid.innerHTML = bufferGridHtml;
        }

        function downloadBackup() {
            save();
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(state));
            const a = document.createElement('a'); a.href = dataStr; a.download = `party_backup_${Date.now()}.json`; a.click();
        }

        function confirmLoadData() {
            if (confirm("경고: 데이터를 로드하면 현재 작업 중인 모든 내용이 삭제되고 덮어씌워집니다.\n\n계속 진행하시겠습니까?")) {
                document.getElementById('load-file').click();
            }
        }

        function handleFileLoad(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const loadedData = JSON.parse(e.target.result);
                    if (!loadedData.characters || !loadedData.contents) {
                        throw new Error("Invalid data structure");
                    }
                    state = { ...state, ...loadedData };
                    if (state.darkMode === undefined) state.darkMode = false;
                    if (state.decimalPlaces === undefined) state.decimalPlaces = 1; // 로드 시 초기값 설정
                    
                    save();
                    applyDarkMode();
                    init(); // 초기화 함수 호출로 UI 업데이트
                    alert("데이터가 성공적으로 로드되었습니다.");
                } catch(err) {
                    alert('올바른 데이터 파일이 아닙니다. (' + err.message + ')');
                } finally {
                    event.target.value = '';
                }
            };
            reader.readAsText(file);
        }

        function closeAddCharModal() { document.getElementById('add-char-modal').classList.remove('active'); }
        function closeAddSetModal() { 
            document.getElementById('add-set-modal').classList.remove('active'); 
            state.editingSetId = null;
        }
        
        window.onload = init;
    </script>
	<footer class="mt-16 text-center text-zinc-400 dark:text-dark-text-muted text-sm">
            &copy; 2026 카인서버 미제레. All rights reserved.
        </footer>
</body>
</html>
